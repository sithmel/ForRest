__doc__ = """
This is a very simple and naive implementation of a tree of resources.
The api is designed work fine with backbone.js
It seems a dictionary with a few key differences: 
 - the keys and values are strings
 - You must request a new key before assign a value
 - every resource has an etag and mimetype
"""

import os
import os.path
from hashlib import md5
import mimetypes
from forrest.app import RestApp

class FileSystem(object):
    def __init__(self, root):
        self.root = root
        self.etags = {}
        # prebuild the dict
        for root, dirs, files in os.walk(self.root):
            for name in files:
                if (not name.startswith('.')):
                    fullpath = os.path.join(root, name)
                    with open(fullpath,'rb') as f: 
                        self.etags[fullpath] = md5(f.read()).hexdigest()

    def _getFilename(self, fn):
        return os.path.join(self.root, fn.lstrip(os.path.sep))

    def _title2id(self, title, mime):
        if not title:
            return 'item'
        if not isinstance(title, unicode):
            title = unicode(title, 'utf-8')
        s = title.encode('ascii', 'ignore')
        s = s.translate(None,'''!"#$%&\'()*+,/:;<=>?@[\\]^`{|}~''')
        extension = mimetypes.guess_extension(mime) or ""
        return "-".join(s.split()) + extension


    def __getitem__(self, key):
        filename = self._getFilename(key)
        try:
            with open(filename, 'rb') as f:
                return f.read()
        except IOError:
            pass
        data = []
        try:
            ls = os.listdir(filename)
        except OSError:
            raise KeyError, 'not found'
        for fname in ls: # throw OSError
            fullpath = os.path.join(filename,fname)
            if not os.path.isfile(fullpath) or fname.startswith('.'):
                continue
            mimetype = self._getMimeType(fullpath)
            if "json" in mimetype:
                try:
                    with open(fullpath) as f:
                        data.append(f.read())
                except IOError:
                    continue # I can't open (maybe is removed)
            else:
                data.append('{"id":"%s","mimetype":"%s"}' % (fname,mimetype) )
        return '[' + ','.join(data) + ']'

    def __setitem__(self, key, value):
        filename = self._getFilename(key)
        if filename not in self.etags:
            raise KeyError
        try:
            with open(filename, 'wb') as f: # throw IOError
                f.write(value)
            self.etags[filename] = md5(value).hexdigest()
        except IOError:
            raise KeyError, 'not found'
        
        
    def __delitem__(self, key):
        filename = self._getFilename(key)
        try:
            os.remove(filename)
            del self.etags[filename]
        except OSError:
            raise KeyError, 'not found'
         

    def new(self, parent, title, mime):
        dirname = self._getFilename(parent)
        if not os.path.isdir(dirname):
            raise KeyError, '%s: not a dir.' % dirname

        newid = self._title2id(title, mime)

        n = 1
        path = os.path.join(dirname, newid)
        p,e = os.path.splitext(path)
        while path in self.etags:
            path = ''.join([p, str(n), e])
            n +=1
        self.etags[path] = None
        newid = os.path.basename(path)
        return newid

    def _getMimeType(self, filename):
        return mimetypes.guess_type(filename)[0]

    def mime(self, key):
        filename = self._getFilename(key)
        if os.path.isdir(filename):
            return 'application/json'
        if os.path.isfile(filename):
            return self._getMimeType(filename)
        raise KeyError

    def etag(self, key):
        filename = self._getFilename(key)
        if os.path.isdir(filename):
            return None
        return self.etags[filename]

def make_app_wsgi(global_conf, path, **kw):
    conf = global_conf.copy()
    conf.update(kw)
    p = os.path

    if not p.isabs(path):
        path = p.normpath(p.join(p.dirname(global_conf['__file__']), path))

    conf['resources'] = FileSystem(path)
    return RestApp(conf)

